import{d as i,e as o,w as s,M as n,a as e,f as t,o as r}from"./index-DO8EIYth.js";const c=i({__name:"AboutView",setup(l){return(h,a)=>(r(),o(n,null,{default:s(()=>a[0]||(a[0]=[e("h1",{class:"title"},"About",-1),e("div",{class:"about"},[e("p",{class:"text"},` One of my favourite things is discovering, learning, and exploring new technologies. Every so often I like to build something new with a lamguage/technology that I've never experienced before. The predecessor to this site was written using a language called Elm which is a functional language that compiles to JavaScript and is designed around building for the web. It was fairly simple, with a ramdomised "fun fact" and some highlights of previous projects below. There's a snippet below containing plenty of functional goodness. `),e("div",{class:"codeblock"},[e("code",{class:""},[t(" update : Msg -> Model -> (Model, Cmd Msg)"),e("br"),t(" update msg model ="),e("br"),t(" Â Â Â Â case msg of"),e("br"),t(" Â Â Â Â Â Â Â Â Loading -> (model, Cmd.batch [ Random.generate Display qualityGenerator ])"),e("br"),t(' Â Â Â Â Â Â Â Â Display q -> ({ model | introduction = "And much more:", subtext = q }, Cmd.none)'),e("br"),t(" Â Â Â Â Â Â Â Â ShowProject p -> ({ model | project = projectEnumerator p }, Cmd.none) ")])]),e("p",{class:"text"},` This site is written in Vue. Or at least the frontend is. I tried Vue for the first time building a small site that was unfortunately lost with a laptop that was past it's best before date. It wasn't even large enough to have a git repo, but I had a great time with Vue, which is what encouraged me to use it when making this site. It has a real feeling of "it just works" for me. Naturally, there isn't a lot of complexity in the site, but what I have experienced of Vue I have appreciated. `),e("p",{class:"text"},[t(" The built files for the project are hosted using Github pages, and the project itself is stored using GitLab. I'd heard good things about GitLab, so I wanted to give it a try. Incidentally, that rounds out my experience of the big four git hosting services, having used GitHub & GitLab personally, and Bitbucket & Azure Devops professionally. In the future I will dive deeper into GitLab pipelines in order to automatically deploy the project, but for the time being this is managed using a good old fashioned "),e("code",null,"deploy.sh"),t(" script, the gory details of which I will spare the readers from. ")]),e("hr",{class:"paragraph-divider"}),e("h3",{class:"title"},"Frontend Design"),e("p",{class:"text"}," The frontend design of the site is effectively based around a mixture of the standard scaffolding set out by creating a new Vue project, alongaside my intuitive idea of how a project should fit together to maximise ease of development, ensuring the site looks nice, and that all important sense that the code is nice. "),e("p",{class:"text"},[t(" The site, in order to be as portable as possible, is a single page application utilising the official Vue router package to render multiple pages. These routes are defined in a TypeScript file setting a path, name, and component that should be rendered in the page. The path set can use a "),e("code",null,"/path/to/page/:id"),t(" form that is familiar to backend frameworks such as Express that allows parameters for the route to be defined and passed to the parent component. These are retrieved in the Vue component using the standard prop creation syntax Â "),e("code",null,"const props = defineProps(['id'])"),t(". Very satisflying and simple to use. ")]),e("p",{class:"text"},[t(" Dark mode is the first-class citizen colour scheme for this site. Personally, it's just what I like to look at when reading a site. But what I always appreciate more than dark mode is a site that is kind enough to make it easy to switch, so I made sure to implement that here. Hello ðŸ‘‹ to anyone reading in light mode. I wanted initially to use the same base colourscheme ("),e("span",{class:"primary"},"primary"),t(" and "),e("span",{class:"secondary"},"secondary"),t("), as I was a big fan of the orange I created. However, that orange is terrible with a white background so I went searching for a new colour. Luckily, while playing around with a colour picker I stumbled upon the purple and knew it was perfect for the site. ")]),e("hr",{class:"paragraph-divider"}),e("h3",{class:"title"},"Backend Design"),e("p",{class:"text"}," Is using a serverless backend potentially slightly overkill for what could be boiled down to a site that displays some paragraphs? Undoubtedly. But that is not the point. Before beginning the project, serverless had been a hole in my knowledge. So I thought it was high time that I took it upon myself to get comfortable developing in the cloud. So I increased the scopr of the site to be a place where I could share blog posts. I've always been appealed by the idea of writing my thoughts, particularly in periods where I'm exploring new technologies. "),e("p",{class:"text"}," So, I decided to build the backend for the site completely decoupled from the frontend. More generally, this is a theme that is growing in the tech community, and I think for good reason. I like the idea of having a completely modular frontend and backend, being able to swap either out at will, with the other half not caring what it connects to. I think this is a great pattern for ensuring that whatever you're building can be flexible enough to use the best tool for the job, even if that changes in the future. "),e("p",{class:"text"}," In practice, I opted to build the backend around AWS. Lambdas for the touchpoints and DynamoDB for storing the blog data. Usually an SQL user, stepping into the world of NoSQL/document databases was interesting, and designing a database schema based on completely different priorities a learning curve. Not using a table per-entity type was almost too much to get my head round to begin with. I have more to say on the AWS learning process, but it's worth leaving that to a post in the future. "),e("p",{class:"text"},` The process of creating, defining, deploying, and iterating with AWS was a fantastic learning experience. Despite there being a few pain-points to navigate (I'm looking at you "defining IAM roles for various steps in the CDK process"), I had a great weekend creating my stack and building a few functions and a database. The final point in this process is deciding how to expose the api endpoints to the frontend. When writing and testing the lambda functions I used function urls (each lambda is given its own url), but I will potentially extend this to use the API gateway for production so I can increase the amount of protection from malicious use and improve the usability of the api (by introducing named endpoints). `)],-1)])),_:1}))}});export{c as default};
